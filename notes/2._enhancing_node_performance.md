# Enhancing Node Performance

![](./images/enhancing_node_performance/two%20ways%20of%20enhancing%20node%20performance.PNG)

### Cluster Mode

It's used to start up multiple copies of Node that are all running your server inside them.
We cannot somehow trick Node to run into running with multiple threads, but by starting up multiple copies we get multiple instances of the Event Loop, so it vaguely works in a similar fashion making Node kind of "multi-threaded".

This is recommended.

It's important to note that _nodemon_ by default out of the box does not work very nicely with clustering.

### Worker Threads

The worker theads are going to use the _threadpool_ that is set up by _libuv_ whenever we start up our Node application.

Be careful, this is way more experimental.

#

![](./images/enhancing_node_performance/node%20from%20request%20to%20response.PNG)

# Blocking the Event Loop

Consider the _2_enhancing_node_performance/1_blockingEventLoop.js_ code, where a simple _express_ server has the following route:

    app.get("/", (req, res) => {
      /* This code is gonna be executed
        inside the Event Loop. This doesn't get
        thrown out to an Event Pool, it doesn't get
        handled by the OS or anything like that.
      */

      /* While processing, our Event Loop
        can do absolutely nothing else, i.e.
        it cannot handle other requests, database queries
        write files, etc*/
      doWork(5000); // 5s.

      res.send("Hi there");
    });

Let's make the 1st request using Firefox, which will take like 5s:
![](./images/enhancing_node_performance/eventloop%20blocked%20request%201.PNG)

Then immediately make the 2nd request:
![](./images/enhancing_node_performance/eventloop%20blocked%20request%202.PNG)

We'll see that the 2nd request takes 10s:
![](./images/enhancing_node_performance/eventloop%20blocked%20results.PNG)

That's why we shouldn't do expensive or long operations inside the Event Loop.

# Node Clustering


